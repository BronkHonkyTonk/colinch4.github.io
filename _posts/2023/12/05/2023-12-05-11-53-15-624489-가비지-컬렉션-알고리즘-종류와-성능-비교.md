---
layout: post
title: "[javascript] 가비지 컬렉션 알고리즘 종류와 성능 비교"
description: " "
date: 2023-12-05
tags: [javascript]
comments: true
share: true
---

가비지 컬렉션은 JavaScript의 메모리 관리를 담당하는 중요한 기능입니다. 가비지 컬렉션 알고리즘은 메모리에서 사용하지 않는 객체를 찾아내고 해제하는 방식을 결정합니다. 이 글에서는 자주 사용되는 가비지 컬렉션 알고리즘 종류와 그들의 성능을 비교해보겠습니다.

## 1. 참조 카운팅(Reference Counting)

참조 카운팅은 객체가 참조되는 횟수를 세고, 참조되는 횟수가 0이 되면 메모리에서 해제하는 방식입니다. 이 방식은 단순하지만 성능상의 이슈가 있습니다. 

**장점**
- 실시간으로 메모리를 해제할 수 있음

**단점**
- 순환 참조를 처리하지 못하므로 메모리 누수가 발생할 수 있음
- 참조 카운팅을 업데이트하는 작업이 오버헤드를 발생시킴

## 2. 마크-앤-스윕(Mark and Sweep)

마크-앤-스윕 알고리즘은 가장 일반적이고 효율적인 가비지 컬렉션 알고리즘입니다. 이 알고리즘은 모든 객체를 순회하면서 참조되는 객체를 마킹하고, 마킹되지 않은 객체는 메모리에서 해제합니다.

**장점**
- 순환 참조 문제를 처리할 수 있음
- 효율적이고 일괄 처리된 메모리 해제 가능

**단점**
- 일시적으로 모든 작업이 중지되므로 일정한 시간이 걸릴 수 있음

## 3. 세대별 가비지 컬렉션(Generational Garbage Collection)

세대별 가비지 컬렉션은 객체를 어느 세대에 속했는지 기록하여 가장 최근에 생성된 객체를 먼저 검사하고, 오랫동안 살아남은 객체들을 나중에 검사하는 방식입니다. 이를 통해 많은 객체가 일반적으로 짧은 생명 주기를 가지는 웹 애플리케이션에서 효율적으로 가비지 컬렉션을 수행할 수 있습니다.

**장점**
- 대부분의 객체가 짧은 생명 주기를 가지므로, 짧은 시간 내에 가비지를 해제할 수 있음
- 오랫동안 살아남은 객체 검사가 상대적으로 적게 일어남

**단점**
- 객체를 세대로 관리하는 추가적인 작업이 필요함

## 성능 비교

가비지 컬렉션 알고리즘의 성능은 다양한 요인에 의해 영향을 받습니다. 알고리즘의 선택은 언어, 환경, 메모리 사용 패턴 등을 고려하여 결정되어야 합니다. 

마크-앤-스윕은 대부분의 상황에서 일반적으로 가장 효율적인 알고리즘이지만, 세대별 가비지 컬렉션은 짧은 생명 주기를 가진 객체를 다루는 경우에 더 효과적입니다. 

또한, 일부 JavaScript 엔진은 여러 가비지 컬렉션 알고리즘을 혼합하여 사용하거나, 최적화된 알고리즘을 제공하기도 합니다. 엔진의 성능과 애플리케이션의 사용 패턴을 고려하여 알고리즘을 선택하는 것이 중요합니다.

## 결론

가비지 컬렉션 알고리즘 중에서도 참조 카운팅, 마크-앤-스윕, 세대별 가비지 컬렉션은 가장 많이 사용되는 알고리즘입니다. 어떤 알고리즘을 선택할지는 애플리케이션의 특성과 요구사항을 고려하여 결정해야 합니다.

참고문헌:
- [MDN Web Docs - Garbage collection](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management#Garbage_collection)
- [JavaScript.info - Garbage collection](https://javascript.info/garbage-collection)