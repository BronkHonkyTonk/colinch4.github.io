---
layout: post
title: "[c++] C++에서의 다중 상속과 인터페이스"
description: " "
date: 2023-12-14
tags: [c++]
comments: true
share: true
---

다중 상속은 C++에서 객체 지향 프로그래밍의 강력한 기능 중 하나입니다. 다중 상속을 사용하면 하나의 클래스가 여러 부모 클래스로부터 상속받을 수 있습니다. 이러한 기능은 코드의 재사용성과 유연성을 높여줍니다. 그러나 다중 상속은 너무 많이 사용하면 코드 복잡성을 증가시킬 수 있으므로 신중하게 사용하여야 합니다.

## 다중 상속의 문제점

다중 상속은 다음과 같은 몇 가지 문제를 야기할 수 있습니다.

### 다이아몬드 문제

다이아몬드 문제는 다수의 클래스가 한 가지 클래스로부터 상속받을 때 발생할 수 있는 충돌 문제입니다. 아래와 같은 상속 구조에서 B와 C 클래스가 모두 A 클래스를 상속받고, D 클래스가 B와 C 클래스를 상속받는 경우 문제가 발생할 수 있습니다.

```
  A
 / \
B   C
 \ /
  D
```

이러한 상황에서 D 클래스는 A 클래스의 멤버를 두 번 상속받게 되는데, 이는 모호한 동작을 초래할 수 있습니다.

### 이름 충돌

두 개 이상의 부모 클래스로부터 같은 이름의 멤버 함수나 변수를 상속받을 경우 이름 충돌이 발생합니다. 이러한 경우에는 파생 클래스에서 어떤 부모 클래스의 멤버를 사용할 지 명시적으로 지정해주어야 합니다.

## 해결 방법

C++에서 다중 상속의 문제를 해결하기 위해 가상 상속(virtual inheritance)을 제공합니다. 이를 통해 다이아몬드 문제를 해결하고, 이름 충돌 문제를 방지할 수 있습니다.

```cpp
class A {
public:
    int value;
};

class B : virtual public A {
};

class C : virtual public A {
};

class D : public B, public C {
};
```

## 인터페이스

C++에서는 인터페이스를 명시적으로 제공하는 언어 기능은 제공되지 않지만, 순수 가상 함수를 활용하여 인터페이스와 유사한 역할을 수행할 수 있습니다. 순수 가상 함수는 부모 클래스에서 구현되지 않고 파생 클래스에서 오버라이딩되어야 하는 함수로, 이러한 함수를 가진 클래스는 해당 함수를 구현해야 합니다.

```cpp
class Interface {
public:
    virtual void execute() = 0;
};

class MyClass : public Interface {
public:
    void execute() override {
        // implementation
    }
};
```

이러한 방식으로 C++에서도 다중 상속과 인터페이스의 개념을 유연하게 활용할 수 있습니다.

## 결론

C++에서의 다중 상속은 강력한 기능이지만 주의해서 사용해야 합니다. 다이아몬드 문제와 이름 충돌을 방지하기 위해 가상 상속을 활용할 수 있으며, 인터페이스와 유사한 기능은 순수 가상 함수를 통해 구현할 수 있습니다.

참고문헌: [cplusplus.com](http://www.cplusplus.com)