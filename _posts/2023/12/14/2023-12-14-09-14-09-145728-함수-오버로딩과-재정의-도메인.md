---
layout: post
title: "[c++] 함수 오버로딩과 재정의 도메인"
description: " "
date: 2023-12-14
tags: [c++]
comments: true
share: true
---

C++는 함수 오버로딩과 함수 재정의를 지원하여 다형성을 구현할 수 있는 강력한 기능을 제공합니다. 함수 오버로딩과 함수 재정의는 객체지향 프로그래밍에서 중요한 개념으로, 이 둘은 서로 다른 목적과 방식으로 사용됩니다.

## 함수 오버로딩

함수 오버로딩은 **동일한 이름을 가진 함수를 여러 개 정의**하는 것을 의미합니다. 이때, 각 함수는 서로 다른 매개변수 타입 또는 개수를 가져야 합니다. 컴파일러는 함수 호출 시 인자의 개수와 타입을 고려하여 적절한 함수를 호출합니다.

```c++
#include <iostream>

void print(int num) {
    std::cout << "정수: " << num << std::endl;
}

void print(double num) {
    std::cout << "실수: " << num << std::endl;
}

int main() {
    print(10);
    print(3.14);
    return 0;
}
```

위 예제에서는 `print` 함수를 정수와 실수 두 가지 버전으로 오버로딩하여 각각 다른 타입의 값을 출력합니다.

## 함수 재정의

함수 재정의는 **기반 클래스의 함수를 파생 클래스에서 다시 정의**하는 것을 의미합니다. 즉, 파생 클래스에서 재정의한 함수는 기반 클래스의 함수와 이름, 매개변수, 반환 값이 일치해야 합니다. 이를 통해 다형성을 구현할 수 있으며, 가상 함수를 통해 동적 바인딩이 가능합니다.

```c++
#include <iostream>

class Animal {
public:
    virtual void makeSound() {
        std::cout << "동물 소리" << std::endl;
    }
};

class Dog : public Animal {
public:
    void makeSound() override {
        std::cout << "멍멍" << std::endl;
    }
};

int main() {
    Animal* animal = new Dog();
    animal->makeSound();   // 동적 바인딩을 통해 Dog 클래스의 makeSound 호출
    return 0;
}
```

위 예제에서는 `Animal` 클래스의 `makeSound` 함수를 파생 클래스 `Dog`에서 재정의하여 각 동물마다 다른 소리를 출력하도록 하였습니다.

## 함수 오버로딩과 재정의의 차이

함수 오버로딩은 **동일한 이름을 가진 함수에 대해 다른 매개변수 타입 또는 개수를 갖는 경우**에 사용되며, 컴파일 시간에 결정됩니다. 반면, 함수 재정의는 **기반 클래스의 함수를 파생 클래스에서 다시 정의하는 경우**에 사용되며, 실행 시간에 결정됩니다.

이러한 차이로 인해 함수 오버로딩은 **정적 바인딩(static binding)**에 의해 호출되는 반면, 함수 재정의는 **동적 바인딩(dynamic binding)**에 의해 호출됩니다. 

따라서, C++에서는 함수 오버로딩과 재정의를 적절히 활용하여 다형성을 구현하고 각각 다른 상황에 맞게 활용할 수 있습니다.

이상으로 C++에서 함수 오버로딩과 함수 재정의에 대해 알아보았습니다. 이 두 가지 기능을 적재적소에 사용하여 객체지향 프로그래밍의 장점을 극대화할 수 있습니다.