---
layout: post
title: "[clojure] Clojure 에이전트와 메시징 모델"
description: " "
date: 2023-12-26
tags: [clojure]
comments: true
share: true
---

Clojure는 JVM 상에서 동작하는 함수형 프로그래밍 언어로, 동시성과 병렬성을 쉽게 다룰 수 있는 기능을 제공합니다. 이러한 기능 중 하나는 **에이전트(Agent)**와 **메시징 모델(Messaging Model)**입니다. 이 글에서는 Clojure의 에이전트와 메시징 모델에 대해 알아보겠습니다.

## 에이전트(Agent)

에이전트는 변경 가능한 상태를 캡슐화하고, 이 상태를 변경하거나 조회하는 동작을 비동기적으로 처리할 수 있는 방법을 제공합니다. **에이전트**는 **send** 함수를 사용하여 상태를 변경하고, **deref** 함수를 사용하여 현재 상태를 조회할 수 있습니다.

아래는 간단한 예제 코드입니다.

```clojure
(def my-agent (agent 0))

(send my-agent + 10)

(println @my-agent)
```

위 코드는 `0`으로 초기화된 `my-agent`라는 에이전트를 생성하고, `send` 함수를 사용하여 상태를 `10` 증가시킨 뒤, `println` 함수로 현재의 상태를 출력합니다.

에이전트는 내부적으로 변경 가능한 상태를 가지고 있지만, 변경은 **동시에 발생**하지 않습니다. 변경은 **비동기적으로 처리**되므로, 여러 스레드가 동시에 에이전트에 메시지를 보내더라도 순차적으로 처리됩니다.

## 메시징 모델(Messaging Model)

Clojure의 메시징 모델은 에이전트 간의 통신과 상태 변경을 관리하는데 사용됩니다. 모든 변경은 **메시지**로 이루어지며, 이를 통해 에이전트에게 변경 명령을 보낼 수 있습니다.

아래는 메시징 모델을 사용하는 예제 코드입니다.

```clojure
(def my-agent (agent 0))

(send my-agent + 10)

(await my-agent)

(println @my-agent)
```

위 코드는 `send` 함수를 사용하여 에이전트에 메시지를 보낸 후, `await` 함수를 사용하여 모든 변경이 완료될 때까지 대기한 뒤, 현재의 상태를 출력합니다.

메시징 모델은 에이전트에게 메시지를 보내고, 그 메시지를 처리할 때까지 기다릴 수 있는 기능을 제공하여 동시성 및 병렬성을 쉽게 다룰 수 있도록 해줍니다.

## 결론

Clojure의 에이전트와 메시징 모델은 동시성과 병렬성을 다루는 데 매우 효율적인 도구입니다. 이를 통해 변경 가능 상태를 관리하고, 여러 스레드나 프로세스 간의 통신을 쉽게 처리할 수 있습니다.

더 많은 정보를 원하시면 [Clojure Documentation](https://clojure.org/index)을 참고하시기 바랍니다.