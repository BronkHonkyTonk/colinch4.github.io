---
layout: post
title: "[go] 시그널 처리 시 주의사항"
description: " "
date: 2023-12-26
tags: [go]
comments: true
share: true
---

시그널은 **고루틴** 간의 통신 및 시스템 이벤트 처리를 위해 사용됩니다. 시그널 처리에는 몇 가지 주의사항이 있으며, 이를 고려하여 **안정적이고 효율적인** 프로그램을 작성해야 합니다.

## 1. 시그널 핸들러에서의 블로킹 호출

시그널 핸들러에서 **무한 루프나 블로킹 호출을** 피해야 합니다. 이는 시스템의 다른 부분에서 발생하는 시그널 처리를 지연시킬 수 있습니다.

```go
signal.Notify(c, syscall.SIGINT, syscall.SIGTERM)
go func() {
    sig := <- c
    // 블로킹 호출을 피하기 위해 여기서 시그널 처리
}()
```

## 2. 공유 자원 접근 시 경합 조건 해결

여러 고루틴이 공유 자원에 접근하는 경우 시그널 핸들러에서도 **경합 조건**이 발생할 수 있습니다. 이를 해결하기 위해 **동기화 메커니즘**을 사용해야 합니다.

```go
var mu sync.Mutex
var sharedResource int

signal.Notify(c, syscall.SIGINT, syscall.SIGTERM)
go func() {
    sig := <- c
    mu.Lock()
    defer mu.Unlock()
    // 공유 자원에 대한 안전한 처리
}()
```

## 3. 시그널 핸들러 내에서의 안전한 동작 보장

시그널 핸들러 내에서는 **안전한 동작**을 보장해야 합니다. 예를 들어, 시스템 호출과 같이 시그널 핸들러 내에서 안전하지 않은 동작을 피해야 합니다. 안전하지 않은 동작을 수행할 경우, 프로그램이 **불안정**해질 수 있습니다.

```go
signal.Notify(c, syscall.SIGINT, syscall.SIGTERM)
go func() {
    sig := <- c
    // 안전한 동작을 수행
}()
```

## 결론

시그널 처리는 안정적이고 효율적인 프로그램을 개발하는 데 중요한 부분입니다. 따라서 시그널 핸들러를 작성할 때에는 **블로킹 호출을 피하고**, **공유 자원에 대한 경합을 해결하며**, **안전한 동작을 보장**해야 합니다. 이를 준수하면 안정적이고 효율적인 프로그램을 개발할 수 있을 것입니다.