---
layout: post
title: "리눅스 프로세스 제어와 스케줄링"
description: " "
date: 2023-09-12
tags: [리눅스]
comments: true
share: true
---

리눅스 운영체제는 많은 프로세스들이 동시에 실행되는 다중 프로세스 환경에서 효율적인 프로세스 제어와 스케줄링을 제공합니다. 이를 통해 시스템의 성능과 안정성을 향상시킬 수 있습니다. 이번 글에서는 리눅스에서의 프로세스 제어와 스케줄링에 대해 알아보도록 하겠습니다.

## 프로세스 제어

리눅스에서 프로세스는 운영체제에 의해 실행 중인 프로그램을 의미합니다. 프로세스의 생성, 제거, 일시 중지, 재개 등을 통해 프로그램의 실행 흐름을 제어할 수 있습니다.

### 프로세스 생성

새로운 프로세스를 생성하는 작업은 `fork()` 시스템 호출을 사용합니다. 이 호출은 부모 프로세스에서 자식 프로세스를 생성하면서 부모 프로세스와 동일한 상태를 복사합니다. 자식 프로세스는 `fork()` 호출 이후로부터 실행을 시작하며, 독립적으로 자신의 작업을 수행합니다.

```c
#include <unistd.h>
#include <stdio.h>

int main() {
    pid_t pid;

    pid = fork();

    if (pid == 0) {
        printf("Child process\n");
    } else if (pid > 0) {
        printf("Parent process\n");
    } else {
        printf("Failed to fork\n");
    }

    return 0;
}
```

### 프로세스 제거

프로세스를 제거하는 작업은 `exit()` 시스템 호출을 사용합니다. 이 호출은 프로세스의 실행을 종료하고 운영체제에게 자원을 반환합니다.

```c
#include <stdlib.h>
#include <stdio.h>

int main() {
    printf("Before exit\n");

    exit(0);

    printf("This line will not be executed\n");

    return 0;
}
```

### 프로세스 일시 중지와 재개

프로세스를 일시 중지하거나 재개하는 작업은 `kill()` 시스템 호출을 사용합니다. `kill()` 호출은 프로세스에 특정 시그널을 보내는 역할을 합니다. `SIGSTOP` 시그널을 보내면 프로세스가 일시 중지되고, `SIGCONT` 시그널을 보내면 프로세스가 재개됩니다.

```c
#include <signal.h>
#include <stdio.h>

int main() {
    printf("Before pause\n");

    pause();

    printf("After pause\n");

    return 0;
}
```

## 스케줄링

리눅스에서 스케줄링은 여러 프로세스의 실행 순서를 결정하는 작업을 의미합니다. 스케줄러는 시스템 자원을 효율적으로 사용하고 프로세스의 우선순위를 조정하여 최적의 성능을 제공합니다.

리눅스의 스케줄러는 기본적으로 `CFS (Completely Fair Scheduler)` 알고리즘을 사용합니다. 이 알고리즘은 프로세스들에게 공정한 CPU 시간을 제공하며, 우선순위를 기반으로 실행 주기를 조절합니다.

여러 스케줄링 정책 중 가장 많이 사용되는 것은 `SCHED_OTHER`입니다. 이 정책은 일반적인 프로세스들을 위한 스케줄링을 수행합니다. 또한, 우선순위를 조절하기 위해 `nice` 명령을 사용할 수 있습니다.

```shell
$ nice -n 5 ./my_program
```

위의 명령은 `my_program`을 실행하는데, 우선순위를 `5`로 설정합니다. 값이 낮을수록 우선순위가 높아집니다.

## 마무리

리눅스에서의 프로세스 제어와 스케줄링은 시스템의 성능과 안정성을 중요시하는 개발자에게 꼭 필요한 기능입니다. 이번 글에서는 리눅스에서의 프로세스 제어와 스케줄링에 대해 간략히 알아보았습니다. 프로세스 제어와 스케줄링은 리눅스 운영체제의 핵심 기능 중 하나이며, 상세한 내용은 개별적으로 공부하여 실제 개발에 적용해보시기를 권장드립니다.