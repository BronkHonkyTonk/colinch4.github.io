---
layout: post
title: "[파이썬] functools `functools.total_ordering` 클래스 데코레이터"
description: " "
date: 2023-09-08
tags: [python,functools]
comments: true
share: true
---

In Python, the `functools` module provides various functions for working with higher-order functions, callable objects, and other utility functions. One of the useful tools offered by the `functools` module is the `total_ordering` class decorator.

## What is `total_ordering` decorator?

The `total_ordering` decorator is a convenient way to define comparison methods for a class, such as `__eq__`, `__ne__`, `__lt__`, `__le__`, `__gt__`, and `__ge__`. By using this decorator, you only need to define one or more of these methods, and the others will be automatically generated for you.

## Why use `total_ordering` decorator?

Implementing comparison operations in Python can be tedious, as you need to define multiple methods for each comparison operator. For example, if you want to make instances of your class sortable, you would need to define both `__lt__` and `__gt__` methods.

By using `total_ordering`, you can define just one or two methods and let Python automatically generate the rest. This saves you from writing repetitive code and ensures consistency between the comparison methods.

## How to use `total_ordering` decorator?

To use the `total_ordering` decorator, follow these steps:

1. Import the `functools` module:
   
   ```python
   import functools
   ```

2. Decorate your class with `total_ordering`:
   
   ```python
   @functools.total_ordering
   class MyClass:
       # Define one or more comparison methods
       def __eq__(self, other):
           # Implement equality comparison logic
           pass

       def __lt__(self, other):
           # Implement less than comparison logic
           pass
   ```

   Note: You only need to define methods for the desired comparison operations. The rest will be generated by the decorator.

Now, you can use all the comparison operators (`==`, `!=`, `<`, `<=`, `>`, `>=`) with instances of your class, and Python will correctly invoke the relevant methods you defined.

## Example Usage

Let's see an example to understand how to use the `total_ordering` decorator:

```python
import functools

@functools.total_ordering
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __eq__(self, other):
        return isinstance(other, Person) and self.age == other.age

    def __lt__(self, other):
        return isinstance(other, Person) and self.age < other.age

# Create instances of Person
person1 = Person("Alice", 25)
person2 = Person("Bob", 30)

# Now we can use comparison operators on Person instances
print(person1 == person2)  # False
print(person1 != person2)  # True
print(person1 < person2)   # True
print(person1 <= person2)  # True
print(person1 > person2)   # False
print(person1 >= person2)  # False
```

In the above example, we define the `Person` class with `total_ordering` decorator. We only implement the `__eq__` and `__lt__` methods, while the rest of the comparison methods are automatically generated.

## Conclusion

The `total_ordering` decorator is a convenient way to define comparison methods for a class in Python. It saves us from writing repetitive code and ensures consistency between the comparison methods. By using this decorator, we can easily make instances of our class sortable and comparable using various operators.